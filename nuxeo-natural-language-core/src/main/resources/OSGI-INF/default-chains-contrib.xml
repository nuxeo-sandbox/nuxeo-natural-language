<?xml version="1.0"?>
<component name="org.nuxeo.natural.language.core.chains">
  <extension target="org.nuxeo.automation.scripting.internals.AutomationScriptingComponent" point="operation">
    <scriptedOperation id="javascript.NaturalLanguageDefaultDocumentProcessing">
      <inputType>Document</inputType>
      <outputType>Document</outputType>
      <category>javascript</category>
      <description></description>
      <script><![CDATA[/* This default mapper:
        - Checks only DOCUMENT_SENTIMENT and ENTITIES, not SYNTAX
        - Save the result as raw JSON String (not complex multivalued)
        - Is optimized: If the API hasalready  been called for the same blob, just do nothing.
*/
function run(input, params) {
  
  var blob, response, ok;
  
  blob = input["file:content"];
  
  // We remove the facet and its schema if the blob is empty or it's not a document we must handle
  // (Trying to extract the full text of a Video or an audio will fail in all cases, etc.)
  if(blob === null || input.hasFacet("Picture") || input.hasFacet("Video") || input.hasFacet("Audio")) {
    if(input.hasFacet("NaturalLanguage")) {
      input = Document.RemoveFacet(input, {'facet': "NaturalLanguage"});
    }
    return input;
  }
  
  // So, the blob is not null. Let's check if we have the schema and if
  // the Natural Language has been processed on the exact same blob already
  if(input.hasSchema("NaturalLanguage") && input["natural_language:source_digest"] === blob.getDigest()) {
    // No need to recompute
    return input;
  }
  
  ok = false;
  try {
    // No choice but compute the thing :-)
    Services.NaturalLanguageDocumentOp(
      input, {
        'features': ['DOCUMENT_SENTIMENT', 'ENTITIES'], //'SYNTAX'
        'outputVariable': "response" /*,
        'provider': , // Using the default provider
        'xpath': // Using the default xpath */
      });
    ok = true;
  } catch(error) {
    Console.log("\nError when calling the Natural Language API:\n" + error);
  }
  
  if(ok) {    
    response = ctx.response;
    
    if(!input.hasFacet("NaturalLanguage")) {
      // "save" parameter available only starting with FT 9.3. Will be ignored with previous
      // versions (and the document is then always saved during this call)
      input = Document.AddFacet(input, {'facet': "NaturalLanguage", "save": false});
    }
       
    input["natural_language:json"] = "" + response.toJSON();    
    input["natural_language:source_digest"] = blob.getDigest();
    input = Document.Save(input, {});
  }
  
  return input;
}
]]></script>
    </scriptedOperation>

    <scriptedOperation id="javascript.VideoVisionDefaultMapper">
      <inputType>Document</inputType>
      <outputType>Document</outputType>
      <category>javascript</category>
      <description></description>
      <script><![CDATA[function run(input, params) {
              var storyboard = input['vid:storyboard'];
              var blobs = [];
              var index;
              var tags = [];

              for (index=0;index<storyboard.length;index++) {

                var blob = storyboard[index].content;

                VisionOp(blob, {
                  'features': ['LABEL_DETECTION'],
                  'maxResults': 5,
                  'outputVariable': 'annotations'
                });

                var annotations = ctx.annotations;

                if (annotations===undefined || annotations.length===0) return;

                // build tag list
                var textAndLabels = annotations[0];
                var labels = textAndLabels.getClassificationLabels();

                if (labels === undefined || labels === null || labels===0) continue;

                for(var j=0;j<labels.length;j++) {
                    var label = labels[j];
                    var tag = label.getText();
                    if (tag ===undefined || tag ===null) continue;
                    tags.push(tag.replace(/[^A-Z0-9]+/ig,'+'));
                    tags.push(label.getText().replace(/\s/g,'+'));
                }
              }

              input = Services.TagDocument(input, {'tags': tags });

              return input;

            }]]></script>
    </scriptedOperation>
  </extension>
</component>
